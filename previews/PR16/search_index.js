var documenterSearchIndex = {"docs":
[{"location":"devdocs/cellvalues/#Cell-Values","page":"Cell Values","title":"Cell Values","text":"","category":"section"},{"location":"devdocs/cellvalues/","page":"Cell Values","title":"Cell Values","text":"FerriteInterfaceElements.get_base_value","category":"page"},{"location":"devdocs/cellvalues/#FerriteInterfaceElements.get_base_value","page":"Cell Values","title":"FerriteInterfaceElements.get_base_value","text":"get_base_value(get_value::Function, cv::InterfaceCellValues, qp::Int, i::Int; here::Bool)\n\nReturn a value from an ::InterfaceCellValues by specifing:\n\nget_value: function specifing which kind of value, e.g. shape_value\nqp: index of the quadrature point\ni: index of the base function\nhere: side of the interface, where true means \"here\" and false means \"there\".\n\n\n\n\n\n","category":"function"},{"location":"devdocs/#Developer-documentation","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Here you can find some documentation of the internals of FerriteInterfaceElements.jl which are useful when developing the library.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Depth = 1\nPages = [    \n    \"cells.md\",\n    \"interpolations.md\",\n    \"cellvalues.md\",\n    ]","category":"page"},{"location":"reference/cells/#Cells-and-grid","page":"Cells and grid","title":"Cells and grid","text":"","category":"section"},{"location":"reference/cells/","page":"Cells and grid","title":"Cells and grid","text":"InterfaceCell\ninsert_interfaces","category":"page"},{"location":"reference/cells/#FerriteInterfaceElements.InterfaceCell","page":"Cells and grid","title":"FerriteInterfaceElements.InterfaceCell","text":"InterfaceCell(here::AbstractCell, there::AbstractCell) <: AbstractCell\n\nAn InterfaceCell is a cell based on two cells of lower dimension representing the two facets. The two base cells need to be of the same type and the order of nodes needs to match, e.g.:\n\n1---2 \"here\"\n4---3 \"there\"\nInterfaceCell(Line((1,2)), Line((4,3)))\n\nFields\n\nhere::AbstractCell: cell representing the facet \"here\"\nthere::AbstractCell: cell representing the facet \"there\"\nnodes::NTuple: tuple with all node indices in appropriate order: vertex nodes \"here\", vertex nodes \"there\", facet nodes \"here\", ...\n\n\n\n\n\n","category":"type"},{"location":"reference/cells/#FerriteInterfaceElements.insert_interfaces","page":"Cells and grid","title":"FerriteInterfaceElements.insert_interfaces","text":"insert_interfaces(grid, domain_names; topology=ExclusiveTopology(grid))\n\nReturn a new grid with InterfaceCells inserted betweenthe domains defined by domain_names. The new grid provides additional cell sets. The set \"interfaces\" contains all new InterfaceCells and two sets are provided for each combination of domain names: \"domain1-domain2-inertface\" and  \"domain2-domain1-inertface\" both using the same Set.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/interpolations/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"devdocs/interpolations/","page":"Interpolation","title":"Interpolation","text":"FerriteInterfaceElements.get_interface_index","category":"page"},{"location":"devdocs/interpolations/#FerriteInterfaceElements.get_interface_index","page":"Interpolation","title":"FerriteInterfaceElements.get_interface_index","text":"get_interface_index(ip::InterfaceCellInterpolation, side::Symbol, i::Integer)\n\nReturn the base function index for an InterfaceCellInterpolation given a side (:here or :there) and the local base function index i on that face.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/#Tutorials","page":"Tutorials overview","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials overview","title":"Tutorials overview","text":"On this page you find a collection of example problems as tutorials on how FerriteInterfaceElements can be used. The tutorials are organized in the same way as for Ferrite.If you are new to Ferrite, you should start there to learn the basics.","category":"page"},{"location":"tutorials/#[Tutorial-1:-Heat-equation](heat_equation.md)","page":"Tutorials overview","title":"Tutorial 1: Heat equation","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials overview","title":"Tutorials overview","text":"This tutorial shows the basics steps using the heat equation as am example case for a scalar problem. A square domain with two phases is considered: a matrix with particle inclusions. First, the required cells at the interface are inserted, then all steps to colve the problem are presented. Finally, a visualization is generated using Makie.","category":"page"},{"location":"tutorials/","page":"Tutorials overview","title":"Tutorials overview","text":"Keywords: scalar-valued solution, Dirichlet boundary conditions,  inserting interface cells, visualization using Makie.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"EditURL = \"../literate-tutorials/heat_equation.jl\"","category":"page"},{"location":"tutorials/heat_equation/#tutorial-heat-equation","page":"Heat equation","title":"Heat equation","text":"","category":"section"},{"location":"tutorials/heat_equation/#Introduction","page":"Heat equation","title":"Introduction","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"In this example, we solve the stationary heat equation in a domain with particles (Omega^textP) embedded in matrix (Omega^textM) with a possible temperature jump at the interface (Gamma^^textPM). For the bulk domains, the following balance law is applied:","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":" -nabla cdot (k nabla u) = f  quad boldsymbolx in Omega^textP cup Omega^textM","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"where u is the unknown temperature field, k the heat conductivity, f the heat source and Omega the domain. For simplicity we set k=1 and f = 0.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"For the interface, we formulate a balance law for the normal heat fluxes q_n^textP and q_n^textM:","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":" q_n^textP + q_n^textM = 0  quad boldsymbolx in Gamma^textPM","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"We define the flux across the interface as:","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":" q_n = q_n^textP = - k_if  u ","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"where k_if is the interface conductivity and  u  is the jump u^textM - u^textP in temperature from the particle to the matrix domain. For simplicity we set k_if = 1.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Note that the two sides of an interface are referred to as \"here\" and \"there\". The provided functions use a jump defined as \"there - here\".","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"The resulting weak form is given given as follows: Find u in mathbbU such that","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":" int_Omega nabla delta u cdot nabla u mathrmdOmega\n int_Gamma^textPtextM  delta u   u  mathrmdGamma\n = 0 quad forall delta u in mathbbT","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"where delta u is a test function, and where mathbbU and mathbbT are suitable trial and test function spaces, respectively.","category":"page"},{"location":"tutorials/heat_equation/#Commented-Program","page":"Heat equation","title":"Commented Program","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Now we solve the problem in Ferrite together with FerriteInterfaceElements. What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"First we load all the packages we need for the computation.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"using Ferrite, FerriteInterfaceElements, SparseArrays, FerriteGmsh","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Then, we load the mesh file periodic-rve.msh (periodic-rve-coarse.msh for a coarser mesh). The mesh is generated with gmsh, and we read it in as a Ferrite grid using the FerriteGmsh package:","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"grid = togrid(\"periodic-rve.msh\")","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"grid = redirect_stdout(devnull) do                #hide\n    togrid(\"periodic-rve-coarse.msh\") #hide\nend                                               #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"So far, this mesh only contains standard cells for the bulk phases. Thus, we need to insert InterfaceCells at the faces between cells in different phases. To do so, we can use the function insert_interfaces. This function creates a new grid with interfaces between subdomains which are defined by names of cellsets which are passed as arguments. The resulting grid includes new cellsets: \"interfaces\" for all interfaces and domain1-domain2-interface\" for interfaces between each pair of subdomains. Note that original cell and face sets are preserved, however, node sets are not.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"grid = insert_interfaces(grid, [\"inclusions\", \"matrix\"]);\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/#Trial-and-test-functions","page":"Heat equation","title":"Trial and test functions","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"First, we define an interpolation and a quadrature rule for both bulk and interface cells.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"ip_bulk = Lagrange{RefTriangle, 1}()\nip_interface = InterfaceCellInterpolation(Lagrange{RefLine, 1}())\n\nqr_bulk = QuadratureRule{RefTriangle}(2)\nqr_interface = QuadratureRule{RefLine}(2);\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"With these definitions, we can create cell values.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"cv_bulk = CellValues(qr_bulk, ip_bulk)\ncv_interface = InterfaceCellValues(qr_interface, ip_interface);\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/#Degrees-of-freedom","page":"Heat equation","title":"Degrees of freedom","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Next we create the DofHandler. Here, one needs distinguish the different types of cells. This can be done by using SubDofHandlers.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"dh = DofHandler(grid)\nset_bulk = union(getcellset(grid, \"inclusions\"), getcellset(grid, \"matrix\"))\nset_interface = getcellset(grid, \"interfaces\")\nadd!(SubDofHandler(dh, set_bulk),      :u, ip_bulk)\nadd!(SubDofHandler(dh, set_interface), :u, ip_interface)\nclose!(dh);\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/#Boundary-conditions","page":"Heat equation","title":"Boundary conditions","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"To construct a simple example and still be able to observe jumps at the interfaces, we fix the temperatur to different values on the particle portion of the boundary.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"particles = getcellset(grid, \"inclusions\")\n∂Ωᴾ_left   = filter(facetindex -> facetindex[1] in particles, getfacetset(grid, \"left\"))\n∂Ωᴾ_right  = filter(facetindex -> facetindex[1] in particles, getfacetset(grid, \"right\"))\n∂Ωᴾ_top    = filter(facetindex -> facetindex[1] in particles, getfacetset(grid, \"top\"))\n∂Ωᴾ_bottom = filter(facetindex -> facetindex[1] in particles, getfacetset(grid, \"bottom\"));\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"We set up a ConstraintHandler with fixed values on the four sides.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"ch = ConstraintHandler(dh)\nadd!(ch, Dirichlet(:u, ∂Ωᴾ_left,   Returns(1.0)))\nadd!(ch, Dirichlet(:u, ∂Ωᴾ_right,  Returns(1.0)))\nadd!(ch, Dirichlet(:u, ∂Ωᴾ_top,    Returns(0.0)))\nadd!(ch, Dirichlet(:u, ∂Ωᴾ_bottom, Returns(0.0)))\nclose!(ch);\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/#Assembling-the-linear-system","page":"Heat equation","title":"Assembling the linear system","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Now we can prepare the assembly of the global system of equations. We start by defining two element assembly functions for the two phases. To distinguish the phases, we use dispatch on the cell value types.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"function assemble_element!(Ke::Matrix, cv::CellValues)\n    fill!(Ke, 0)\n    for qp in 1:getnquadpoints(cv)\n        dΩ = getdetJdV(cv, qp)\n        for i in 1:getnbasefunctions(cv)\n            ∇δu = shape_gradient(cv, qp, i)\n            for j in 1:getnbasefunctions(cv)\n                ∇u = shape_gradient(cv, qp, j)\n                Ke[i, j] += (∇δu ⋅ ∇u) * dΩ\n            end\n        end\n    end\n    return Ke\nend\n\nfunction assemble_element!(Ke::Matrix, cv::InterfaceCellValues)\n    fill!(Ke, 0)\n    for qp in 1:getnquadpoints(cv)\n        dΩ = getdetJdV_average(cv, qp)\n        for i in 1:getnbasefunctions(cv)\n            jump_δu = shape_value_jump(cv, qp, i)\n            for j in 1:getnbasefunctions(cv)\n                jump_u = shape_value_jump(cv, qp, j)\n                Ke[i, j] += (jump_δu * jump_u) * dΩ\n            end\n        end\n    end\n    return Ke\nend;\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Next, we define a function that performs the assembly for a given set of cells.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"function assemble_set!(assembler, set, dh, cv)\n    nbf = getnbasefunctions(cv)\n    Ke = zeros(nbf, nbf)\n    for cc in CellIterator(dh, set)\n        reinit!(cv, cc)\n        assemble_element!(Ke, cv)\n        assemble!(assembler, celldofs(cc), Ke)\n    end\n    return assembler\nend;\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"This can then be used in a function for preparing the system of equations.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"function prepare_system(dh, cv_bulk, cv_interface, set_bulk, set_interface)\n    K = create_sparsity_pattern(dh)\n    assembler = start_assemble(K)\n    assemble_set!(assembler, set_bulk,      dh, cv_bulk)\n    assemble_set!(assembler, set_interface, dh, cv_interface)\n    return K, zeros(ndofs(dh))\nend;\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/#Solution-and-visualization","page":"Heat equation","title":"Solution and visualization","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Finally, the system of equations can be assembled and solved.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"K, f = prepare_system(dh, cv_bulk, cv_interface, set_bulk, set_interface)\napply!(K, f, ch)\nu = K \\ f;\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"To visualize the computed result, we will write a simple function for plotting the temperature using Makie. The first important step is translating the Ferrite grid to a representation Makie can use.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"import Makie, GeometryBasics\n\nfunction convert_nodes(grid::Grid{dim}) where {dim}\n    return collect( GeometryBasics.Point{dim,Float64}(n.x...) for n in grid.nodes )\nend\n\nfunction convert_cells(::Grid)\n    bulkcells = filter(c -> !(c isa InterfaceCell), grid.cells) # `InterfaceCell`s are not plotted\n    return collect( GeometryBasics.TriangleFace{Int}(cell.nodes...) for cell in bulkcells )\nend\n\nfunction prepare_plotable_mesh(grid::Grid)\n    return GeometryBasics.Mesh(convert_nodes(grid), convert_cells(grid))\nend","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"The nex step is to get the nodal temperature values. However, the Ferrite function evaluate_at_grid_nodes does not (yet) work for interface elements. Thus, we need to rearrange the solution vector ourselves. Althought it is not the most efficient way, a simple solution is to iterate over the bulk cells and use the DOF mapping of each cell.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"function get_nodal_temperatures(u::AbstractVector, dh::DofHandler)\n    grid = dh.grid\n    bulkcells = union( getcellset(grid, \"inclusions\"), getcellset(grid, \"matrix\") )\n    uₙ = zeros(length(grid.nodes))\n    for cc in CellIterator(dh, bulkcells)\n        cell = getcells(grid, cc.cellid.x)\n        dofs = celldofs(cc)\n        nodes = [cell.nodes...]\n        uₙ[nodes] .= u[dofs]\n    end\n    return uₙ\nend;\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Finally, a function can be defined to create the desired plot.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"function plot_temperature(u::Vector, dh::DofHandler)\n    mesh = prepare_plotable_mesh(dh.grid)\n    temperature = get_nodal_temperatures(u, dh)\n\n    fig = Makie.Figure()\n    ax = Makie.Axis(fig[1,1]; title=\"Solution\", aspect=Makie.DataAspect())\n    p = Makie.mesh!(ax, mesh; color=temperature, colormap=:heat)\n    Makie.Colorbar(fig[1,2], p; label=\"u\", labelrotation=0)\n    return fig\nend;\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Using this function we can create and save a visualization.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"import CairoMakie\nfig = plot_temperature(u, dh)\nCairoMakie.save(\"heat_equation_result.png\", fig);\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"(Image: )","category":"page"},{"location":"tutorials/heat_equation/#heat_equation-plain-program","page":"Heat equation","title":"Plain program","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Here follows a version of the program without any comments. The file is also available here: heat_equation.jl.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"using Ferrite, FerriteInterfaceElements, SparseArrays, FerriteGmsh\n\n# grid = togrid(\"periodic-rve-coarse.msh\")\ngrid = togrid(\"periodic-rve.msh\")\n\ngrid = insert_interfaces(grid, [\"inclusions\", \"matrix\"]);\n\nip_bulk = Lagrange{RefTriangle, 1}()\nip_interface = InterfaceCellInterpolation(Lagrange{RefLine, 1}())\n\nqr_bulk = QuadratureRule{RefTriangle}(2)\nqr_interface = QuadratureRule{RefLine}(2);\n\ncv_bulk = CellValues(qr_bulk, ip_bulk)\ncv_interface = InterfaceCellValues(qr_interface, ip_interface);\n\ndh = DofHandler(grid)\nset_bulk = union(getcellset(grid, \"inclusions\"), getcellset(grid, \"matrix\"))\nset_interface = getcellset(grid, \"interfaces\")\nadd!(SubDofHandler(dh, set_bulk),      :u, ip_bulk)\nadd!(SubDofHandler(dh, set_interface), :u, ip_interface)\nclose!(dh);\n\nparticles = getcellset(grid, \"inclusions\")\n∂Ωᴾ_left   = filter(facetindex -> facetindex[1] in particles, getfacetset(grid, \"left\"))\n∂Ωᴾ_right  = filter(facetindex -> facetindex[1] in particles, getfacetset(grid, \"right\"))\n∂Ωᴾ_top    = filter(facetindex -> facetindex[1] in particles, getfacetset(grid, \"top\"))\n∂Ωᴾ_bottom = filter(facetindex -> facetindex[1] in particles, getfacetset(grid, \"bottom\"));\n\nch = ConstraintHandler(dh)\nadd!(ch, Dirichlet(:u, ∂Ωᴾ_left,   Returns(1.0)))\nadd!(ch, Dirichlet(:u, ∂Ωᴾ_right,  Returns(1.0)))\nadd!(ch, Dirichlet(:u, ∂Ωᴾ_top,    Returns(0.0)))\nadd!(ch, Dirichlet(:u, ∂Ωᴾ_bottom, Returns(0.0)))\nclose!(ch);\n\nfunction assemble_element!(Ke::Matrix, cv::CellValues)\n    fill!(Ke, 0)\n    for qp in 1:getnquadpoints(cv)\n        dΩ = getdetJdV(cv, qp)\n        for i in 1:getnbasefunctions(cv)\n            ∇δu = shape_gradient(cv, qp, i)\n            for j in 1:getnbasefunctions(cv)\n                ∇u = shape_gradient(cv, qp, j)\n                Ke[i, j] += (∇δu ⋅ ∇u) * dΩ\n            end\n        end\n    end\n    return Ke\nend\n\nfunction assemble_element!(Ke::Matrix, cv::InterfaceCellValues)\n    fill!(Ke, 0)\n    for qp in 1:getnquadpoints(cv)\n        dΩ = getdetJdV_average(cv, qp)\n        for i in 1:getnbasefunctions(cv)\n            jump_δu = shape_value_jump(cv, qp, i)\n            for j in 1:getnbasefunctions(cv)\n                jump_u = shape_value_jump(cv, qp, j)\n                Ke[i, j] += (jump_δu * jump_u) * dΩ\n            end\n        end\n    end\n    return Ke\nend;\n\nfunction assemble_set!(assembler, set, dh, cv)\n    nbf = getnbasefunctions(cv)\n    Ke = zeros(nbf, nbf)\n    for cc in CellIterator(dh, set)\n        reinit!(cv, cc)\n        assemble_element!(Ke, cv)\n        assemble!(assembler, celldofs(cc), Ke)\n    end\n    return assembler\nend;\n\nfunction prepare_system(dh, cv_bulk, cv_interface, set_bulk, set_interface)\n    K = create_sparsity_pattern(dh)\n    assembler = start_assemble(K)\n    assemble_set!(assembler, set_bulk,      dh, cv_bulk)\n    assemble_set!(assembler, set_interface, dh, cv_interface)\n    return K, zeros(ndofs(dh))\nend;\n\nK, f = prepare_system(dh, cv_bulk, cv_interface, set_bulk, set_interface)\napply!(K, f, ch)\nu = K \\ f;\n\nimport Makie, GeometryBasics\n\nfunction convert_nodes(grid::Grid{dim}) where {dim}\n    return collect( GeometryBasics.Point{dim,Float64}(n.x...) for n in grid.nodes )\nend\n\nfunction convert_cells(::Grid)\n    bulkcells = filter(c -> !(c isa InterfaceCell), grid.cells) # `InterfaceCell`s are not plotted\n    return collect( GeometryBasics.TriangleFace{Int}(cell.nodes...) for cell in bulkcells )\nend\n\nfunction prepare_plotable_mesh(grid::Grid)\n    return GeometryBasics.Mesh(convert_nodes(grid), convert_cells(grid))\nend\n\nfunction get_nodal_temperatures(u::AbstractVector, dh::DofHandler)\n    grid = dh.grid\n    bulkcells = union( getcellset(grid, \"inclusions\"), getcellset(grid, \"matrix\") )\n    uₙ = zeros(length(grid.nodes))\n    for cc in CellIterator(dh, bulkcells)\n        cell = getcells(grid, cc.cellid.x)\n        dofs = celldofs(cc)\n        nodes = [cell.nodes...]\n        uₙ[nodes] .= u[dofs]\n    end\n    return uₙ\nend;\n\nfunction plot_temperature(u::Vector, dh::DofHandler)\n    mesh = prepare_plotable_mesh(dh.grid)\n    temperature = get_nodal_temperatures(u, dh)\n\n    fig = Makie.Figure()\n    ax = Makie.Axis(fig[1,1]; title=\"Solution\", aspect=Makie.DataAspect())\n    p = Makie.mesh!(ax, mesh; color=temperature, colormap=:heat)\n    Makie.Colorbar(fig[1,2], p; label=\"u\", labelrotation=0)\n    return fig\nend;\n\nimport CairoMakie\nfig = plot_temperature(u, dh)\nCairoMakie.save(\"heat_equation_result.png\", fig);","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"devdocs/cells/#Cells-and-grid","page":"Cells and grid","title":"Cells and grid","text":"","category":"section"},{"location":"devdocs/cells/#Working-with-interface-cells","page":"Cells and grid","title":"Working with interface cells","text":"","category":"section"},{"location":"devdocs/cells/","page":"Cells and grid","title":"Cells and grid","text":"FerriteInterfaceElements.get_interface_cell_shape\nFerriteInterfaceElements.get_sides_and_base_indices","category":"page"},{"location":"devdocs/cells/#FerriteInterfaceElements.get_interface_cell_shape","page":"Cells and grid","title":"FerriteInterfaceElements.get_interface_cell_shape","text":"get_interface_cell_shape(::Type{<:AbstractRefShape})\n\nReturn the shape of an interface given a base reference shape. E.g. given RefTriangle, RefPrism is returned, meaning two triangles form an interface based on a prism.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/cells/#FerriteInterfaceElements.get_sides_and_base_indices","page":"Cells and grid","title":"FerriteInterfaceElements.get_sides_and_base_indices","text":"get_sides_and_base_indices(::InterfaceCell)\nget_sides_and_base_indices(::AbstractCell)\nget_sides_and_base_indices(::Type{<:AbstractCell})\n\nReturn a tuple containing tuples of a symbol (:here or :there) and an integer. The index of the outer tuple represents the node index. In the inner tuple, the symbol represents the side the node is on  and the integer represents the nodes index in the base cell.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/cells/#Inserting-interface-cells-into-a-grid","page":"Cells and grid","title":"Inserting interface cells into a grid","text":"","category":"section"},{"location":"devdocs/cells/","page":"Cells and grid","title":"Cells and grid","text":"FerriteInterfaceElements.create_interface_cell\nFerriteInterfaceElements.get_interface_base_cell_type","category":"page"},{"location":"devdocs/cells/#FerriteInterfaceElements.create_interface_cell","page":"Cells and grid","title":"FerriteInterfaceElements.create_interface_cell","text":"create_interface_cell(::Type{C}, nodes_here, nodes_there) where {C}\n\nReturn a suitable InterfaceCell connecting the facets with nodes_here and nodes_there.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/cells/#FerriteInterfaceElements.get_interface_base_cell_type","page":"Cells and grid","title":"FerriteInterfaceElements.get_interface_base_cell_type","text":"get_interface_base_cell_type(::Type{<:AbstractCell})\n\nReturn a suitable base type for connecting two cells of given type with an InterfaceCell.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reference","page":"Reference overview","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference overview","title":"Reference overview","text":"Pages = [\n    \"cells.md\",\n    \"interpolations.md\",\n    \"cellvalues.md\",\n]","category":"page"},{"location":"reference/cellvalues/#Cell-Values","page":"Cell Values","title":"Cell Values","text":"","category":"section"},{"location":"reference/cellvalues/","page":"Cell Values","title":"Cell Values","text":"InterfaceCellValues\nFerrite.shape_value(cv::InterfaceCellValues, qp::Int, i::Int; here::Bool)\nFerrite.shape_gradient(cv::InterfaceCellValues, qp::Int, i::Int; here::Bool)\nFerrite.function_value(cv::InterfaceCellValues, qp::Int, u::AbstractVector, dof_range=eachindex(u); here::Bool)\nFerrite.function_gradient(cv::InterfaceCellValues, qp::Int, u::AbstractVector, dof_range=eachindex(u); here::Bool)\nshape_value_average\nshape_gradient_average\nshape_value_jump\nshape_gradient_jump\nfunction_value_average\nfunction_gradient_average\nfunction_value_jump\nfunction_gradient_jump\ngetdetJdV_average\nget_side_and_baseindex","category":"page"},{"location":"reference/cellvalues/#FerriteInterfaceElements.InterfaceCellValues","page":"Cell Values","title":"FerriteInterfaceElements.InterfaceCellValues","text":"InterfaceCellValues([::Type{T},] qr::QuadratureRule, func_ip::InterfaceCellInterpolation, [geom_ip::InterfaceCellInterpolation]; use_same_cv=true)\n\nAn InterfaceCellValues is based on two CellValues: one for each facet of an InterfaceCell. Since one can use the same CellValues for both sides, be default the same object is used for better performance. The keyword argument use_same_cv can be set to false to disable this behavior, if needed.\n\nFields\n\nip::InterfaceCellInterpolation: interpolation on the interface\nhere::CellValues:  values for facet \"here\"\nthere::CellValues:  values for facet \"there\"\nbase_indices_here::Vector{Int}: base function indices on facet \"here\"\nbase_indices_there::Vector{Int}: base function indices on facet \"there\"\nsides_and_baseindices::Tuple: side and base function for the base CellValues for each base function of the InterfaceCellValues\n\n\n\n\n\n","category":"type"},{"location":"reference/cellvalues/#Ferrite.shape_value-Tuple{InterfaceCellValues, Int64, Int64}","page":"Cell Values","title":"Ferrite.shape_value","text":"shape_value(cv::InterfaceCellValues, qp::Int, i::Int; here::Bool)\n\nReturn the value of shape function i evaluated in quadrature point qp on side here, where true means \"here\" and false means \"there\".\n\n\n\n\n\n","category":"method"},{"location":"reference/cellvalues/#Ferrite.shape_gradient-Tuple{InterfaceCellValues, Int64, Int64}","page":"Cell Values","title":"Ferrite.shape_gradient","text":"shape_gradient(cv::InterfaceCellValues, qp::Int, i::Int; here::Bool)\n\nReturn the gradient of shape function i evaluated in quadrature point qp on side here, where true means \"here\" and false means \"there\".\n\n\n\n\n\n","category":"method"},{"location":"reference/cellvalues/#Ferrite.function_value","page":"Cell Values","title":"Ferrite.function_value","text":"function_value(cv::InterfaceCellValues, qp::Int, u::AbstractVector; here::Bool)\n\nCompute the value of the function in a quadrature point on side here, where true means \"here\" and false means \"there\". u is a vector with values for the degrees of freedom.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.function_gradient","page":"Cell Values","title":"Ferrite.function_gradient","text":"function_gradient(cv::InterfaceCellValues, qp::Int, u::AbstractVector; here::Bool)\n\nCompute the gradient of the function in a quadrature point on side here, where true means \"here\" and false means \"there\". u is a vector with values for the degrees of freedom.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.shape_value_average","page":"Cell Values","title":"Ferrite.shape_value_average","text":"shape_value_average(cv::InterfaceCellValues, qp::Int, i::Int)\n\nReturn the value of shape function i evaluated in quadrature point qp for computing the average value on an interface.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.shape_gradient_average","page":"Cell Values","title":"Ferrite.shape_gradient_average","text":"shape_gradient_average(cv::InterfaceCellValues, qp::Int, i::Int)\n\nReturn the gradient of shape function i evaluated in quadrature point qp for computing the average gradient on an interface.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.shape_value_jump","page":"Cell Values","title":"Ferrite.shape_value_jump","text":"shape_value_jump(cv::InterfaceCellValues, qp::Int, i::Int)\n\nReturn the value of shape function i evaluated in quadrature point qp for computing the value jump on an interface. The jump is defined as \"here - there\".\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.shape_gradient_jump","page":"Cell Values","title":"Ferrite.shape_gradient_jump","text":"shape_gradient_jump(cv::InterfaceCellValues, qp::Int, i::Int)\n\nReturn the gradient of shape function i evaluated in quadrature point qp for computing the gradient jump on an interface. The jump is defined as \"here - there\".\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.function_value_average","page":"Cell Values","title":"Ferrite.function_value_average","text":"function_value_average(cv::InterfaceCellValues, qp::Int, u::AbstractVector)\n\nCompute the average value of the function in a quadrature point.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.function_gradient_average","page":"Cell Values","title":"Ferrite.function_gradient_average","text":"function_gradient_average(cv::InterfaceCellValues, qp::Int, u::AbstractVector)\n\nCompute the average gradient of the function in a quadrature point.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.function_value_jump","page":"Cell Values","title":"Ferrite.function_value_jump","text":"function_value_jump(cv::InterfaceCellValues, qp::Int, u::AbstractVector)\n\nCompute the jump of the function value in a quadrature point. The jump is defined as \"here - there\".\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.function_gradient_jump","page":"Cell Values","title":"Ferrite.function_gradient_jump","text":"function_gradient_jump(cv::InterfaceCellValues, qp::Int, u::AbstractVector)\n\nCompute the jump of the function gradient in a quadrature point. The jump is defined as \"here - there\".\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#FerriteInterfaceElements.getdetJdV_average","page":"Cell Values","title":"FerriteInterfaceElements.getdetJdV_average","text":"getdetJdV_average(cv::InterfaceCellValues, qp::Int)\n\nReturn the average of the product between the determinant of the Jacobian on each side of the interface and the quadrature point weight for the given quadrature point: det(J(mathbfx)) w_q.\n\nThis value is typically used when integrating a function on the mid-plane of an interface element.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#FerriteInterfaceElements.get_side_and_baseindex","page":"Cell Values","title":"FerriteInterfaceElements.get_side_and_baseindex","text":"get_side_and_baseindex(cv::InterfaceCellInterpolation, i::Integer)\nget_side_and_baseindex(cv::InterfaceCellValues, i::Integer)\n\nFor an InterfaceCellInterpolation: given the base function index i return the side (:here or :there)  and the base function index locally on that side.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FerriteInterfaceElements","category":"page"},{"location":"#FerriteInterfaceElements.jl","page":"Home","title":"FerriteInterfaceElements.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for FerriteInterfaceElements! FerriteInterfaceElements adds functionality to the finite element toolbox Ferrite for working with interface elements (also known as cohesive elements).","category":"page"},{"location":"#How-the-documentation-is-organized","page":"Home","title":"How the documentation is organized","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The documentation assumes that you are already familiar with the basic usage of Ferrite. If not, you should first take a look at the Ferrite documentation. Here, only the additional tools are explained.","category":"page"},{"location":"","page":"Home","title":"Home","text":"After a basic introduction on this side, the document is organized as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorials are documented examples which guide you through the process of solving partial differential equations with interface terms.\nReference contains the technical API reference of functions and methods (e.g. the documentation strings).","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As a new user of FerriteInterfaceElements it is suggested to read the introduction on this side and then start working with the tutorials before using FerriteInterfaceElements to tackle the  specific equation you ultimately want to solve.","category":"page"},{"location":"#Getting-help","page":"Home","title":"Getting help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have questions about FerriteInterfaceElements it is suggested to use the #ferrite-fem channel on the Julia Slack, or the #Ferrite.jl stream on Zulip. Alternatively you can use the discussion forum on the GitHub repository.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use FerriteInterfaceElements you first need to install Julia, see https://julialang.org/ for details. Installing FerriteInterfaceElements can then be done from the Pkg REPL; press ] at the julia> promp to enter pkg> mode:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add FerriteInterfaceElements","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install FerriteInterfaceElements and all necessary dependencies. Press backspace to get back to the julia> prompt. (See the documentation for Pkg, Julia's package manager, for more help regarding package installation and project management.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note, that you also need to install Ferrite, which can be done in the same way.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, to load Ferrite and FerriteInterfaceElements, use","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Ferrite, FerriteInterfaceElements","category":"page"},{"location":"","page":"Home","title":"Home","text":"You are now all set to start using FerriteInterfaceElements!","category":"page"},{"location":"#Introduction-to-interface-elements","page":"Home","title":"Introduction to interface elements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Interface elements can be used to allow for jumps in fields on interfaces between finite elements. They can be considered as elements with zero thickness and two faces (one for each side of the interface).","category":"page"},{"location":"","page":"Home","title":"Home","text":"In FerriteInterfaceElements, their implementation is based on the idea to combine two embedded elements to represent the to sides of an interface. At the current state, it is only supported to use the same interpolation on both sides. To distinguish the two sides, they are referred to as here and there. The jump of a field is then defined as field here - field there.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Another key definition is the reference shape of interface elements. In FerriteInterfaceElements, the shape is chosen to be of the same dimension as the surrounding bulk elements. The specific shape is then determined from the shape of the underlying base shapes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"reference shape of faces shape of the interface element\nRefLine RefQuadrilateral\nRefTriangle RefPrism\nRefQuadrilateral RefHexahedron","category":"page"},{"location":"","page":"Home","title":"Home","text":"These definitions have been made to use as much of the existing functionalities in Ferrite as possible on the types for working with interface elements:","category":"page"},{"location":"","page":"Home","title":"Home","text":"InterfaceCell\nInterfaceCellInterpolation\nInterfaceCellValues","category":"page"},{"location":"","page":"Home","title":"Home","text":"These types can be used similar to the corresponding types in Ferrite. However, they come with new functions for evaluations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"getdetJdV_average\nshape_value_jump\nshape_value_average\nfunction_value_jump\n...","category":"page"},{"location":"reference/interpolations/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"reference/interpolations/","page":"Interpolation","title":"Interpolation","text":"InterfaceCellInterpolation","category":"page"},{"location":"reference/interpolations/#FerriteInterfaceElements.InterfaceCellInterpolation","page":"Interpolation","title":"FerriteInterfaceElements.InterfaceCellInterpolation","text":"InterfaceCellInterpolation(ip::ScalarInterpolation) <: ScalarInterpolation\n\nAn InterfaceCellInterpolation is based on a regular interpolation which will be applied  to both facets of an InterfaceCell.\n\nFields\n\nbase::ScalarInterpolation: base interpolation\n\n\n\n\n\n","category":"type"}]
}
