var documenterSearchIndex = {"docs":
[{"location":"devdocs/cellvalues/#Cell-Values","page":"Cell Values","title":"Cell Values","text":"","category":"section"},{"location":"devdocs/cellvalues/","page":"Cell Values","title":"Cell Values","text":"FerriteInterfaceElements.get_base_value","category":"page"},{"location":"devdocs/cellvalues/#FerriteInterfaceElements.get_base_value","page":"Cell Values","title":"FerriteInterfaceElements.get_base_value","text":"get_base_value(get_value::Function, cv::InterfaceCellValues, qp::Int, i::Int, here::Bool)\n\nReturn a value from an ::InterfaceCellValues by specifing:\n\nget_value: function specifing which kind of value, e.g. shape_value\nqp: index of the quadrature point\ni: index of the base function\nhere: side of the interface, where true means \"here\" and false means \"there\".\n\n\n\n\n\n","category":"function"},{"location":"devdocs/#Developer-documentation","page":"Developer documentation","title":"Developer documentation","text":"","category":"section"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Here you can find some documentation of the internals of FerriteInterfaceElements.jl which are useful when developing the library.","category":"page"},{"location":"devdocs/","page":"Developer documentation","title":"Developer documentation","text":"Depth = 1\nPages = [    \n    \"cells.md\",\n    \"interpolations.md\",\n    \"cellvalues.md\",\n    ]","category":"page"},{"location":"devdocs/interpolations/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"devdocs/interpolations/","page":"Interpolation","title":"Interpolation","text":"FerriteInterfaceElements.get_n_dofs_on_side\nFerriteInterfaceElements.get_interface_index\nFerriteInterfaceElements.get_interface_dof_indices","category":"page"},{"location":"devdocs/interpolations/#FerriteInterfaceElements.get_n_dofs_on_side","page":"Interpolation","title":"FerriteInterfaceElements.get_n_dofs_on_side","text":"get_n_dofs_on_side(get_dofs::Function, ip::InterfaceCellInterpolation, side::Symbol)\n\nReturn the number of DOFs on a side (:here or :there) of an InterfaceCellInterpolation. The function get_dofs specifies which DOFs are considered, e.g. by passing vertexdof_indices.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/interpolations/#FerriteInterfaceElements.get_interface_index","page":"Interpolation","title":"FerriteInterfaceElements.get_interface_index","text":"get_interface_index(ip::InterfaceCellInterpolation, side::Symbol, i::Integer)\n\nReturn the base function index for an InterfaceCellInterpolation given a side (:here or :there) and the local base function index i on that face.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/interpolations/#FerriteInterfaceElements.get_interface_dof_indices","page":"Interpolation","title":"FerriteInterfaceElements.get_interface_dof_indices","text":"get_interface_dof_indices(get_dofs::Function, ip::InterfaceCellInterpolation)\n\nReturn a tuple of tuples with DOF indices for different entities (vertices, faces, etc.). The function get_dofs specifies which DOFs are considered, e.g. by passing vertexdof_indices.\n\n\n\n\n\n","category":"function"},{"location":"tutorials/#Tutorials","page":"Tutorials overview","title":"Tutorials","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials overview","title":"Tutorials overview","text":"On this page you find a collection of example problems as tutorials on how FerriteInterfaceElements can be used. The tutorials are organized in the same way as for Ferrite.If you are new to Ferrite, you should start there to learn the basics.","category":"page"},{"location":"tutorials/#[Tutorial-1:-Heat-equation](heat_equation.md)","page":"Tutorials overview","title":"Tutorial 1: Heat equation","text":"","category":"section"},{"location":"tutorials/","page":"Tutorials overview","title":"Tutorials overview","text":"This tutorial shows the basics steps using the heat equation as am example case for a scalar problem. A square domain with two phases is considered: a matrix with particle inclusions. First, the required cells at the interface are inserted, then all steps to colve the problem are presented. Finally, a visualization is generated using Makie.","category":"page"},{"location":"tutorials/","page":"Tutorials overview","title":"Tutorials overview","text":"Keywords: scalar-valued solution, Dirichlet boundary conditions,  inserting interface cells, visualization using Makie.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"EditURL = \"../literate-tutorials/heat_equation.jl\"","category":"page"},{"location":"tutorials/heat_equation/#tutorial-heat-equation","page":"Heat equation","title":"Heat equation","text":"","category":"section"},{"location":"tutorials/heat_equation/#Introduction","page":"Heat equation","title":"Introduction","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"In this example, we solve the stationary heat equation in a domain with particles (Omega^textP) embedded in matrix (Omega^textM) with a possible temperature jump at the interface (Gamma^^textPM). For the bulk domains, the following balance law is applied:","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":" -nabla cdot (k nabla u) = f  quad boldsymbolx in Omega^textP cup Omega^textM","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"where u is the unknown temperature field, k the heat conductivity, f the heat source and Omega the domain. For simplicity we set k=1 and f = 0.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"For the interface, we formulate a balance law for the normal heat fluxes q_n^textP and q_n^textM:","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":" q_n^textP + q_n^textM = 0  quad boldsymbolx in Gamma^textPM","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"We define the flux across the interface as:","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":" q_n = q_n^textP = - k_if  u ","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"where k_if is the interface conductivity and  u  is the jump u^textM - u^textP in temperature from the particle to the matrix domain. For simplicity we set k_if = 1.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Note that the two sides of an interface are referred to as \"here\" and \"there\". The provided functions use a jump as defined from \"here\" to \"there\". So, in this example the particles are to be considered the side \"here\". (Here, this is not that relevant, since the sign of the jump has no influence on the result in the weak form. In general, this could be relevant.)","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"The resulting weak form is given given as follows: Find u in mathbbU such that","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":" int_Omega nabla delta u cdot nabla u mathrmdOmega\n int_Gamma^textPtextM  delta u   u  mathrmdGamma\n = 0 quad forall delta u in mathbbT","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"where delta u is a test function, and where mathbbU and mathbbT are suitable trial and test function sets, respectively.","category":"page"},{"location":"tutorials/heat_equation/#Commented-Program","page":"Heat equation","title":"Commented Program","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Now we solve the problem in Ferrite together with FerriteInterfaceElements. What follows is a program spliced with comments. The full program, without comments, can be found in the next section.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"First we load all the packages we need.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"using Ferrite, FerriteInterfaceElements, SparseArrays\nFerrite.facedof_interior_indices(::Lagrange{RefLine}) = Tuple{}() # Hot fix -> TODO: remove ASAP","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"We first load the mesh file periodic-rve.msh (periodic-rve-coarse.msh for a coarser mesh). The mesh is generated with gmsh, and we read it in as a Ferrite grid using the FerriteGmsh package:","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"using FerriteGmsh\ngrid = togrid(\"periodic-rve.msh\")","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"grid = redirect_stdout(devnull) do                #hide\n    togrid(\"periodic-rve-coarse.msh\") #hide\nend                                               #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"So far, this mesh only contains standard cells for the bulk phases. Thus, we need to insert InterfaceCells at the faces between cells in different phases. To do so, we can use the function create_interface_cells!. Note that this function does not insert the InterfaceCells into the grid! (That would require changing the type of grid.cells.) The function adds duplicates of nodes on the interface to the grid, disconnects cells of different phases and returns cells which can be used to connect them via interfaces.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"interface_cells = create_interface_cells!(grid::Grid, \"inclusions\", \"matrix\");\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Now, we create a new grid with all the needed cells. For convenience, we also add a new cell set with the interface cells.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"n_bulk_cells = length(grid.cells)\nn_interface_cells = length(interface_cells)\nset_interface = Set{Int}(n_bulk_cells + 1 : n_bulk_cells + n_interface_cells)\n\ngrid = Grid(vcat(grid.cells, interface_cells), grid.nodes; cellsets=grid.cellsets, facesets=grid.facesets)\naddcellset!(grid, \"interface\", set_interface);\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/#Trial-and-test-functions","page":"Heat equation","title":"Trial and test functions","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"First, we define an interpolation and a quadrature rule for both bulk and interface cells.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"ip_bulk = Lagrange{RefTriangle, 1}()\nip_interface = InterfaceCellInterpolation(Lagrange{RefLine, 1}())\n\nqr_bulk = QuadratureRule{RefTriangle}(2)\nqr_interface = QuadratureRule{RefLine}(2);\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"With these definitions, we can create cell values.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"cv_bulk = CellValues(qr_bulk, ip_bulk)\ncv_interface = InterfaceCellValues(qr_interface, ip_interface);\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/#Degrees-of-freedom","page":"Heat equation","title":"Degrees of freedom","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Next we create the DofHandler. Here ones needs distinguish the different types of cells. This can be done by using SubDofHandlers.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"dh = DofHandler(grid)\nset_bulk = union(getcellset(grid, \"inclusions\"), getcellset(grid, \"matrix\"))\nadd!(SubDofHandler(dh, set_bulk),      :u, ip_bulk)\nadd!(SubDofHandler(dh, set_interface), :u, ip_interface)\nclose!(dh);\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/#Boundary-conditions","page":"Heat equation","title":"Boundary conditions","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"To construct a simple example, but be still be able to observe jumps at the interfaces, we fix the temperatur to different values on the particle portion of the boundary.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"particles = getcellset(grid, \"inclusions\")\n∂Ωᴾ_left   = filter(faceindex -> faceindex[1] in particles, getfaceset(grid, \"left\"))\n∂Ωᴾ_right  = filter(faceindex -> faceindex[1] in particles, getfaceset(grid, \"right\"))\n∂Ωᴾ_top    = filter(faceindex -> faceindex[1] in particles, getfaceset(grid, \"top\"))\n∂Ωᴾ_bottom = filter(faceindex -> faceindex[1] in particles, getfaceset(grid, \"bottom\"));\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"We set up a ConstraintHandler with for fixed values on the four sides.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"ch = ConstraintHandler(dh)\nadd!(ch, Dirichlet(:u, ∂Ωᴾ_left,   Returns(0.25)))\nadd!(ch, Dirichlet(:u, ∂Ωᴾ_right,  Returns(0.75)))\nadd!(ch, Dirichlet(:u, ∂Ωᴾ_top,    Returns(0.5)))\nadd!(ch, Dirichlet(:u, ∂Ωᴾ_bottom, Returns(0.0)))\nclose!(ch);\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/#Assembling-the-linear-system","page":"Heat equation","title":"Assembling the linear system","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Now we can prepare the assembly of the global system of equations. We start by defining two element assembly functions for the two phases. To distinguish the phases, we use dispatch und the cell value types.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"function assemble_element!(Ke::Matrix, cv::CellValues)\n    fill!(Ke, 0)\n    for qp in 1:getnquadpoints(cv)\n        dΩ = getdetJdV(cv, qp)\n        for i in 1:getnbasefunctions(cv)\n            ∇δu = shape_gradient(cv, qp, i)\n            for j in 1:getnbasefunctions(cv)\n                ∇u = shape_gradient(cv, qp, j)\n                Ke[i, j] += (∇δu ⋅ ∇u) * dΩ\n            end\n        end\n    end\n    return Ke\nend\n\nfunction assemble_element!(Ke::Matrix, cv::InterfaceCellValues)\n    fill!(Ke, 0)\n    for qp in 1:getnquadpoints(cv)\n        dΩ = getdetJdV_average(cv, qp)\n        for i in 1:getnbasefunctions(cv)\n            jump_δu = shape_value_jump(cv, qp, i)\n            for j in 1:getnbasefunctions(cv)\n                jump_u = shape_value_jump(cv, qp, j)\n                Ke[i, j] += (jump_δu * jump_u) * dΩ\n            end\n        end\n    end\n    return Ke\nend;\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Next, we define a function that performs the assembly for a given set of cells.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"function assemble_set!(assembler, set::Set{Int}, dh, cv)\n    nbf = getnbasefunctions(cv)\n    Ke = zeros(nbf, nbf)\n    for cc in CellIterator(dh, set)\n        reinit!(cv, cc)\n        assemble_element!(Ke, cv)\n        assemble!(assembler, celldofs(cc), Ke)\n    end\n    return assembler\nend;\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"This can then be used in a function for preparing the system of equations.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"function prepare_system(dh, cv_bulk, cv_interface, set_bulk, set_interface)\n    K = create_sparsity_pattern(dh)\n    assembler = start_assemble(K)\n    assemble_set!(assembler, set_bulk,      dh, cv_bulk)\n    assemble_set!(assembler, set_interface, dh, cv_interface)\n    return K, zeros(ndofs(dh))\nend;\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/#Solution-and-visualization","page":"Heat equation","title":"Solution and visualization","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Finally, the system of equations can be assembled and solved.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"K, f = prepare_system(dh, cv_bulk, cv_interface, set_bulk, set_interface)\napply!(K, f, ch)\nu = K \\ f;\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"To visualize the computed result, we will write a simple function for plotting the temperature using Makie. The first important step is translating the Ferrite grid to a representation Makie can use.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"import Makie, GeometryBasics\n\nfunction convert_nodes(grid::Grid{dim}) where {dim}\n    return collect( GeometryBasics.Point{dim,Float64}(n.x...) for n in grid.nodes )\nend\n\nfunction convert_cells(::Grid)\n    bulkcells = filter(c -> !(c isa InterfaceCell), grid.cells) # `InterfaceCell`s are not plotted\n    return collect( GeometryBasics.TriangleFace{Int}(cell.nodes...) for cell in bulkcells )\nend\n\nfunction prepare_plotable_mesh(grid::Grid)\n    return GeometryBasics.Mesh(convert_nodes(grid), convert_cells(grid))\nend","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"The nex step is to get the nodal temperature values. However, the Ferrite function evaluate_at_grid_nodes does not (yet) work for interface elements. Thus, we need to rearrange the solution vector ourselves. Althought it is not the most effiecient way, a simple solution is to iterate over the bulk cells and use the DOF mapping of each cell.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"function get_nodal_temperatures(u::AbstractVector, dh::DofHandler)\n    grid = dh.grid\n    bulkcells = union( getcellset(grid, \"inclusions\"), getcellset(grid, \"matrix\") )\n    uₙ = zeros(length(grid.nodes))\n    for cc in CellIterator(dh, bulkcells)\n        cell = getcells(grid, cc.cellid.x)\n        dofs = celldofs(cc)\n        nodes = [cell.nodes...]\n        uₙ[nodes] .= u[dofs]\n    end\n    return uₙ\nend;\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Finally, a function can be defined to create the desired plot.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"function plot_temperature(u::Vector, dh::DofHandler)\n    mesh = prepare_plotable_mesh(dh.grid)\n    temperature = get_nodal_temperatures(u, dh)\n\n    fig = Makie.Figure()\n    ax = Makie.Axis(fig[1,1]; title=\"Solution\")\n    p = Makie.mesh!(ax, mesh; color=temperature, colormap=:heat)\n    Makie.Colorbar(fig[1,2], p; label=\"u\", labelrotation=0)\n    return fig\nend;\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Using this function we can create and save a visualization.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"import CairoMakie\nfig = plot_temperature(u, dh)\nCairoMakie.save(\"heat_equation_result.png\", fig);\nnothing #hide","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"(Image: )","category":"page"},{"location":"tutorials/heat_equation/#heat_equation-plain-program","page":"Heat equation","title":"Plain program","text":"","category":"section"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"Here follows a version of the program without any comments. The file is also available here: heat_equation.jl.","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"using Ferrite, FerriteInterfaceElements, SparseArrays\nFerrite.facedof_interior_indices(::Lagrange{RefLine}) = Tuple{}() # Hot fix -> TODO: remove ASAP\n\nusing FerriteGmsh\n# grid = togrid(\"periodic-rve-coarse.msh\")\ngrid = togrid(\"periodic-rve.msh\")\n\ninterface_cells = create_interface_cells!(grid::Grid, \"inclusions\", \"matrix\");\n\nn_bulk_cells = length(grid.cells)\nn_interface_cells = length(interface_cells)\nset_interface = Set{Int}(n_bulk_cells + 1 : n_bulk_cells + n_interface_cells)\n\ngrid = Grid(vcat(grid.cells, interface_cells), grid.nodes; cellsets=grid.cellsets, facesets=grid.facesets)\naddcellset!(grid, \"interface\", set_interface);\n\nip_bulk = Lagrange{RefTriangle, 1}()\nip_interface = InterfaceCellInterpolation(Lagrange{RefLine, 1}())\n\nqr_bulk = QuadratureRule{RefTriangle}(2)\nqr_interface = QuadratureRule{RefLine}(2);\n\ncv_bulk = CellValues(qr_bulk, ip_bulk)\ncv_interface = InterfaceCellValues(qr_interface, ip_interface);\n\ndh = DofHandler(grid)\nset_bulk = union(getcellset(grid, \"inclusions\"), getcellset(grid, \"matrix\"))\nadd!(SubDofHandler(dh, set_bulk),      :u, ip_bulk)\nadd!(SubDofHandler(dh, set_interface), :u, ip_interface)\nclose!(dh);\n\nparticles = getcellset(grid, \"inclusions\")\n∂Ωᴾ_left   = filter(faceindex -> faceindex[1] in particles, getfaceset(grid, \"left\"))\n∂Ωᴾ_right  = filter(faceindex -> faceindex[1] in particles, getfaceset(grid, \"right\"))\n∂Ωᴾ_top    = filter(faceindex -> faceindex[1] in particles, getfaceset(grid, \"top\"))\n∂Ωᴾ_bottom = filter(faceindex -> faceindex[1] in particles, getfaceset(grid, \"bottom\"));\n\nch = ConstraintHandler(dh)\nadd!(ch, Dirichlet(:u, ∂Ωᴾ_left,   Returns(0.25)))\nadd!(ch, Dirichlet(:u, ∂Ωᴾ_right,  Returns(0.75)))\nadd!(ch, Dirichlet(:u, ∂Ωᴾ_top,    Returns(0.5)))\nadd!(ch, Dirichlet(:u, ∂Ωᴾ_bottom, Returns(0.0)))\nclose!(ch);\n\nfunction assemble_element!(Ke::Matrix, cv::CellValues)\n    fill!(Ke, 0)\n    for qp in 1:getnquadpoints(cv)\n        dΩ = getdetJdV(cv, qp)\n        for i in 1:getnbasefunctions(cv)\n            ∇δu = shape_gradient(cv, qp, i)\n            for j in 1:getnbasefunctions(cv)\n                ∇u = shape_gradient(cv, qp, j)\n                Ke[i, j] += (∇δu ⋅ ∇u) * dΩ\n            end\n        end\n    end\n    return Ke\nend\n\nfunction assemble_element!(Ke::Matrix, cv::InterfaceCellValues)\n    fill!(Ke, 0)\n    for qp in 1:getnquadpoints(cv)\n        dΩ = getdetJdV_average(cv, qp)\n        for i in 1:getnbasefunctions(cv)\n            jump_δu = shape_value_jump(cv, qp, i)\n            for j in 1:getnbasefunctions(cv)\n                jump_u = shape_value_jump(cv, qp, j)\n                Ke[i, j] += (jump_δu * jump_u) * dΩ\n            end\n        end\n    end\n    return Ke\nend;\n\nfunction assemble_set!(assembler, set::Set{Int}, dh, cv)\n    nbf = getnbasefunctions(cv)\n    Ke = zeros(nbf, nbf)\n    for cc in CellIterator(dh, set)\n        reinit!(cv, cc)\n        assemble_element!(Ke, cv)\n        assemble!(assembler, celldofs(cc), Ke)\n    end\n    return assembler\nend;\n\nfunction prepare_system(dh, cv_bulk, cv_interface, set_bulk, set_interface)\n    K = create_sparsity_pattern(dh)\n    assembler = start_assemble(K)\n    assemble_set!(assembler, set_bulk,      dh, cv_bulk)\n    assemble_set!(assembler, set_interface, dh, cv_interface)\n    return K, zeros(ndofs(dh))\nend;\n\nK, f = prepare_system(dh, cv_bulk, cv_interface, set_bulk, set_interface)\napply!(K, f, ch)\nu = K \\ f;\n\nimport Makie, GeometryBasics\n\nfunction convert_nodes(grid::Grid{dim}) where {dim}\n    return collect( GeometryBasics.Point{dim,Float64}(n.x...) for n in grid.nodes )\nend\n\nfunction convert_cells(::Grid)\n    bulkcells = filter(c -> !(c isa InterfaceCell), grid.cells) # `InterfaceCell`s are not plotted\n    return collect( GeometryBasics.TriangleFace{Int}(cell.nodes...) for cell in bulkcells )\nend\n\nfunction prepare_plotable_mesh(grid::Grid)\n    return GeometryBasics.Mesh(convert_nodes(grid), convert_cells(grid))\nend\n\nfunction get_nodal_temperatures(u::AbstractVector, dh::DofHandler)\n    grid = dh.grid\n    bulkcells = union( getcellset(grid, \"inclusions\"), getcellset(grid, \"matrix\") )\n    uₙ = zeros(length(grid.nodes))\n    for cc in CellIterator(dh, bulkcells)\n        cell = getcells(grid, cc.cellid.x)\n        dofs = celldofs(cc)\n        nodes = [cell.nodes...]\n        uₙ[nodes] .= u[dofs]\n    end\n    return uₙ\nend;\n\nfunction plot_temperature(u::Vector, dh::DofHandler)\n    mesh = prepare_plotable_mesh(dh.grid)\n    temperature = get_nodal_temperatures(u, dh)\n\n    fig = Makie.Figure()\n    ax = Makie.Axis(fig[1,1]; title=\"Solution\")\n    p = Makie.mesh!(ax, mesh; color=temperature, colormap=:heat)\n    Makie.Colorbar(fig[1,2], p; label=\"u\", labelrotation=0)\n    return fig\nend;\n\nimport CairoMakie\nfig = plot_temperature(u, dh)\nCairoMakie.save(\"heat_equation_result.png\", fig);","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"","category":"page"},{"location":"tutorials/heat_equation/","page":"Heat equation","title":"Heat equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"devdocs/cells/#Cells","page":"Cells","title":"Cells","text":"","category":"section"},{"location":"devdocs/cells/#Working-with-interface-cells","page":"Cells","title":"Working with interface cells","text":"","category":"section"},{"location":"devdocs/cells/","page":"Cells","title":"Cells","text":"FerriteInterfaceElements.get_interface_cell_shape\nFerriteInterfaceElements.get_sides_and_base_indices","category":"page"},{"location":"devdocs/cells/#FerriteInterfaceElements.get_interface_cell_shape","page":"Cells","title":"FerriteInterfaceElements.get_interface_cell_shape","text":"get_interface_cell_shape(::Type{<:AbstractRefShape})\n\nReturn the shape of an interface given a base reference shape. E.g. given RefTriangle, RefPrism is returned, meaning two triangles form an interface based on a prism.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/cells/#FerriteInterfaceElements.get_sides_and_base_indices","page":"Cells","title":"FerriteInterfaceElements.get_sides_and_base_indices","text":"get_sides_and_base_indices(c::InterfaceCell)\nget_sides_and_base_indices(::AbstractCell, ::AbstractCell)\nget_sides_and_base_indices(::Type{<:AbstractRefShape}, ::Type{<:AbstractRefShape})\n\nReturn a tuple containing tuples of a symbol (:here or :there) and an integer. The index of the outer tuple represents the node index. In the inner tuple, the symbol represents the side the node is on  and the integer represents the nodes index in the base cell.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/cells/#Inserting-interface-cells-into-a-grid","page":"Cells","title":"Inserting interface cells into a grid","text":"","category":"section"},{"location":"devdocs/cells/","page":"Cells","title":"Cells","text":"FerriteInterfaceElements.find_interfaces\nFerriteInterfaceElements.insert_duplicate_nodes!\nFerriteInterfaceElements.face_node_indices\nFerriteInterfaceElements.create_face_cell\nFerriteInterfaceElements.create_interface_cell\nFerriteInterfaceElements.create_interface_cells\nFerriteInterfaceElements.collect_cells_to_be_adapted\nFerriteInterfaceElements.adapt_cell\nFerriteInterfaceElements.adapt_cells!","category":"page"},{"location":"devdocs/cells/#FerriteInterfaceElements.find_interfaces","page":"Cells","title":"FerriteInterfaceElements.find_interfaces","text":"find_interfaces(grid::Grid, top::ExclusiveTopology, here::Set, there::Set)\n\nReturn a Set{FaceIndex} with all faces of cells in here that are shared with a cell in there and a Set{Int} with all node indices on the interface.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/cells/#FerriteInterfaceElements.insert_duplicate_nodes!","page":"Cells","title":"FerriteInterfaceElements.insert_duplicate_nodes!","text":"insert_duplicate_nodes!(grid::Grid, targetnodes::Set{Int})\n\nAdd duplicates of all nodes specified by targetnodes to grid.nodes. Return a Dict{Int,Int} as mapping of a given node index to the index of the duplicate.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/cells/#FerriteInterfaceElements.face_node_indices","page":"Cells","title":"FerriteInterfaceElements.face_node_indices","text":"face_node_indices(::Type{<:AbstractRefShape})\n\nReturn a tuple of tuples containing the local node indices of all faces.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/cells/#FerriteInterfaceElements.create_face_cell","page":"Cells","title":"FerriteInterfaceElements.create_face_cell","text":"create_face_cell(::Type{<:Ferrite.AbstractCell}, cell::Ferrite.AbstractCell, face::Int)\n\nReturn a new cell for a given face of an existing cell.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/cells/#FerriteInterfaceElements.create_interface_cell","page":"Cells","title":"FerriteInterfaceElements.create_interface_cell","text":"create_interface_cell(grid::Grid, interface::FaceIndex, nodemapping::Dict{Int,Int})\n\nCreates an InterfaceCell at the specified face in the grid. The nodemapping is used to get the node indices of the required duplicate nodes.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/cells/#FerriteInterfaceElements.create_interface_cells","page":"Cells","title":"FerriteInterfaceElements.create_interface_cells","text":"create_interface_cells(grid::Grid, interfaces::Set{FaceIndex}, nodemapping::Dict{Int,Int})\n\nCreates InterfaceCells at the specified faces in the grid. The nodemapping is used to get the node indices of the required duplicate nodes.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/cells/#FerriteInterfaceElements.collect_cells_to_be_adapted","page":"Cells","title":"FerriteInterfaceElements.collect_cells_to_be_adapted","text":"collect_cells_to_be_adapted(grid::Grid, top::ExclusiveTopology, interfaces::Set{FaceIndex}, here::Set, there::Set)\n\nReturn a Set{Int} with the indices of all cells for which existing node indices need  to be replaced by indices of duplicates.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/cells/#FerriteInterfaceElements.adapt_cell","page":"Cells","title":"FerriteInterfaceElements.adapt_cell","text":"adapt_cell(cell::AbstractCell, nodemapping::Dict{Int,Int})\n\nReturn a new cell where existing node indices habe beenreplaced according to nodemapping.\n\n\n\n\n\n","category":"function"},{"location":"devdocs/cells/#FerriteInterfaceElements.adapt_cells!","page":"Cells","title":"FerriteInterfaceElements.adapt_cells!","text":"adapt_cells!(grid::Grid, top::ExclusiveTopology, interfaces::Set{FaceIndex}, here::Set, there::Set, nodemapping::Dict{Int,Int})\n\nChange existing node indices as needed for cells at the interface.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reference","page":"Reference overview","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference overview","title":"Reference overview","text":"Pages = [\n    \"grid.md\",\n    \"interpolations.md\",\n    \"cellvalues.md\",\n]","category":"page"},{"location":"reference/grid/#Interface-Cells","page":"Interface Cells","title":"Interface Cells","text":"","category":"section"},{"location":"reference/grid/","page":"Interface Cells","title":"Interface Cells","text":"InterfaceCell\ncreate_interface_cells!","category":"page"},{"location":"reference/grid/#FerriteInterfaceElements.InterfaceCell","page":"Interface Cells","title":"FerriteInterfaceElements.InterfaceCell","text":"InterfaceCell(here::AbstractCell, there::AbstractCell) <: AbstractCell\n\nAn InterfaceCell is a cell based on two cells of lower dimension representing the two faces. The two base cells need to use the same reference shape and the order of nodes needs to match, e.g.:\n\n1---2 \"here\"\n4---3 \"there\"\nInterfaceCell(Line((1,2)), Line((4,3)))\n\nFields\n\nhere::AbstractCell: cell representing the face \"here\"\nthere::AbstractCell: cell representing the face \"there\"\nnodes::NTuple: tuple with all node indices in appropriate order: vertex nodes \"here\", vertex nodes \"there\", face nodes \"here\", ...\n\n\n\n\n\n","category":"type"},{"location":"reference/grid/#FerriteInterfaceElements.create_interface_cells!","page":"Interface Cells","title":"FerriteInterfaceElements.create_interface_cells!","text":"create_interface_cells!(grid::Grid, here, there)\n\nCreate InterfaceCells between cells in the sets here and there (as Strings or Set{Int}). Duplicate nodes are added to the grid and existing cells are adapted, so that cells in here and there are no longer connected. Return a Vector with InterfaceCells connecting here and there.\n\nWARNING: Interfaces which are not closed can lead to ambiguities!\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Cell-Values","page":"Cell Values","title":"Cell Values","text":"","category":"section"},{"location":"reference/cellvalues/","page":"Cell Values","title":"Cell Values","text":"InterfaceCellValues\nFerrite.shape_value(cv::InterfaceCellValues, qp::Int, i::Int, here::Bool)\nFerrite.shape_gradient(cv::InterfaceCellValues, qp::Int, i::Int, here::Bool)\nFerrite.function_value(cv::InterfaceCellValues, qp::Int, u::AbstractVector, here::Bool, dof_range = eachindex(u))\nFerrite.function_gradient(cv::InterfaceCellValues, qp::Int, u::AbstractVector, here::Bool, dof_range = eachindex(u))\nshape_value_average\nshape_gradient_average\nshape_value_jump\nshape_gradient_jump\nfunction_value_average\nfunction_gradient_average\nfunction_value_jump\nfunction_gradient_jump\ngetdetJdV_average\nget_side_and_baseindex","category":"page"},{"location":"reference/cellvalues/#FerriteInterfaceElements.InterfaceCellValues","page":"Cell Values","title":"FerriteInterfaceElements.InterfaceCellValues","text":"InterfaceCellValues([::Type{T},] qr::QuadratureRule, func_ip::InterfaceCellInterpolation, [geom_ip::InterfaceCellInterpolation])\n\nAn InterfaceCellValues wraps two CellValues, one for each face of an InterfaceCell.\n\nFields\n\nip::InterfaceCellInterpolation: interpolation on the interface\nhere::CellValues:  values on face \"here\"\nthere::CellValues: values on face \"there\"\nbasefunctionshere::Vector{Int}: base function indices on face \"here\"\nbasefunctionsthere::Vector{Int}: base function indices on face \"there\"\n\n\n\n\n\n","category":"type"},{"location":"reference/cellvalues/#Ferrite.shape_value-Tuple{InterfaceCellValues, Int64, Int64, Bool}","page":"Cell Values","title":"Ferrite.shape_value","text":"shape_value(cv::InterfaceCellValues, qp::Int, i::Int, here::Bool)\n\nReturn the value of shape function i evaluated in quadrature point qp on side here, where true means \"here\" and false means \"there\".\n\n\n\n\n\n","category":"method"},{"location":"reference/cellvalues/#Ferrite.shape_gradient-Tuple{InterfaceCellValues, Int64, Int64, Bool}","page":"Cell Values","title":"Ferrite.shape_gradient","text":"shape_gradient(cv::InterfaceCellValues, qp::Int, i::Int, here::Bool)\n\nReturn the gradient of shape function i evaluated in quadrature point qp on side here, where true means \"here\" and false means \"there\".\n\n\n\n\n\n","category":"method"},{"location":"reference/cellvalues/#Ferrite.function_value","page":"Cell Values","title":"Ferrite.function_value","text":"function_value(cv::InterfaceCellValues, qp::Int, u::AbstractVector, here::Bool)\n\nCompute the value of the function in a quadrature point on side here, where true means \"here\" and false means \"there\". u is a vector with values for the degrees of freedom.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.function_gradient","page":"Cell Values","title":"Ferrite.function_gradient","text":"function_gradient(cv::InterfaceCellValues, qp::Int, u::AbstractVector, here::Bool)\n\nCompute the gradient of the function in a quadrature point on side here, where true means \"here\" and false means \"there\". u is a vector with values for the degrees of freedom.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.shape_value_average","page":"Cell Values","title":"Ferrite.shape_value_average","text":"shape_value_average(cv::InterfaceCellValues, qp::Int, i::Int)\n\nReturn the value of shape function i evaluated in quadrature point qp for computing the average value on an interface.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.shape_gradient_average","page":"Cell Values","title":"Ferrite.shape_gradient_average","text":"shape_gradient_average(cv::InterfaceCellValues, qp::Int, i::Int)\n\nReturn the gradient of shape function i evaluated in quadrature point qp for computing the average gradient on an interface.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.shape_value_jump","page":"Cell Values","title":"Ferrite.shape_value_jump","text":"shape_value_jump(cv::InterfaceCellValues, qp::Int, i::Int)\n\nReturn the value of shape function i evaluated in quadrature point qp for computing the value jump on an interface.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.shape_gradient_jump","page":"Cell Values","title":"Ferrite.shape_gradient_jump","text":"shape_gradient_jump(cv::InterfaceCellValues, qp::Int, i::Int)\n\nReturn the gradient of shape function i evaluated in quadrature point qp for computing the gradient jump on an interface.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.function_value_average","page":"Cell Values","title":"Ferrite.function_value_average","text":"function_value_average(cv::InterfaceCellValues, qp::Int, u::AbstractVector)\n\nCompute the average value of the function in a quadrature point.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.function_gradient_average","page":"Cell Values","title":"Ferrite.function_gradient_average","text":"function_gradient_average(cv::InterfaceCellValues, qp::Int, u::AbstractVector)\n\nCompute the average gradient of the function in a quadrature point.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.function_value_jump","page":"Cell Values","title":"Ferrite.function_value_jump","text":"function_value_jump(cv::InterfaceCellValues, qp::Int, u::AbstractVector)\n\nCompute the jump of the function value in a quadrature point.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#Ferrite.function_gradient_jump","page":"Cell Values","title":"Ferrite.function_gradient_jump","text":"function_gradient_jump(cv::InterfaceCellValues, qp::Int, u::AbstractVector)\n\nCompute the jump of the function gradient in a quadrature point.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#FerriteInterfaceElements.getdetJdV_average","page":"Cell Values","title":"FerriteInterfaceElements.getdetJdV_average","text":"getdetJdV_average(cv::InterfaceCellValues, qp::Int)\n\nReturn the average of the product between the determinant of the Jacobian on each side of the interface and the quadrature point weight for the given quadrature point: det(J(mathbfx)) w_q.\n\nThis value is typically used when integrating a function on the mid-plane of an interface element.\n\n\n\n\n\n","category":"function"},{"location":"reference/cellvalues/#FerriteInterfaceElements.get_side_and_baseindex","page":"Cell Values","title":"FerriteInterfaceElements.get_side_and_baseindex","text":"get_side_and_baseindex(cv::InterfaceCellValues, i::Integer)\n\nFor an ::InterfaceCellValues: given the base function index i return the side (:here or :there) the base function belongs to and the corresponding index for the CellValues belonging to that side.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = FerriteInterfaceElements","category":"page"},{"location":"#FerriteInterfaceElements.jl","page":"Home","title":"FerriteInterfaceElements.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for FerriteInterfaceElements! FerriteInterfaceElements is adding functionality to the finite element toolbox Ferrite for working with interface elements (also known as cohesive elements).","category":"page"},{"location":"#How-the-documentation-is-organized","page":"Home","title":"How the documentation is organized","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We assume that you are already familiar with the basic usage of Ferrite. If not, you should first take a look at the Ferrite documentation. Here, only the additional tools are explained.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This high level view of the documentation structure will help you find what you are looking for. After a basic introduction on this side, the document is organized as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorials are documented examples which guide you through the process of solving partial differential equations with interface terms.\nReference contains the technical API reference of functions and methods (e.g. the documentation strings).","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As a new user of FerriteInterfaceElements it is suggested to read the introduction on this side and then start working with the tutorials before using FerriteInterfaceElements to tackle the  specific equation you ultimately want to solve.","category":"page"},{"location":"#Getting-help","page":"Home","title":"Getting help","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have questions about FerriteInterfaceElements it is suggested to use the #ferrite-fem channel on the Julia Slack, or the #Ferrite.jl stream on Zulip. Alternatively you can use the discussion forum on the GitHub repository.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use FerriteInterfaceElements you first need to install Julia, see https://julialang.org/ for details. Installing FerriteInterfaceElements can then be done from the Pkg REPL; press ] at the julia> promp to enter pkg> mode:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add FerriteInterfaceElements","category":"page"},{"location":"","page":"Home","title":"Home","text":"This will install FerriteInterfaceElements and all necessary dependencies. Press backspace to get back to the julia> prompt. (See the documentation for Pkg, Julia's package manager, for more help regarding package installation and project management.)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note, that you also need to install Ferrite, which can be done in the same way.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Finally, to load Ferrite and FerriteInterfaceElements, use","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Ferrite, FerriteInterfaceElements","category":"page"},{"location":"","page":"Home","title":"Home","text":"You are now all set to start using FerriteInterfaceElements!","category":"page"},{"location":"#Introduction-to-interface-elements","page":"Home","title":"Introduction to interface elements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Interface elements can be used to allow for jumps in fields on interfaces between finite elements. They can be considered as elements with zero thickness and two faces (one for each side of the interface).","category":"page"},{"location":"","page":"Home","title":"Home","text":"In FerriteInterfaceElements, their implementation is based on the idea to combine two embedded elements to represent the to sides of an interface. To distinguish the two sides, they are referred to as here and there. The jump of a field is then defined as from here to there: field there - field here.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Another key definition is the reference shape of interface elements. In FerriteInterfaceElements, the shape is chosen to be of the same dimension as the surrounding bulk elements. The specific shape is then determined from the shape of the underlying base shapes:","category":"page"},{"location":"","page":"Home","title":"Home","text":"reference shape of faces shape of the interface element\nRefLine RefQuadrilateral\nRefTriangle RefPrism\nRefQuadrilateral RefHexahedron","category":"page"},{"location":"","page":"Home","title":"Home","text":"These definitions have been made to use as much of the existing functionalities in Ferrite as possible on the types for working with interface elements:","category":"page"},{"location":"","page":"Home","title":"Home","text":"InterfaceCell\nInterfaceCellInterpolation\nInterfaceCellValues","category":"page"},{"location":"","page":"Home","title":"Home","text":"These types can be used similar to the corresponding types in Ferrite. However, they come with new functions for evaluations:","category":"page"},{"location":"","page":"Home","title":"Home","text":"getdetJdV_average\nshape_value_jump\nshape_value_average\nfunction_value_jump\n...","category":"page"},{"location":"reference/interpolations/#Interpolation","page":"Interpolation","title":"Interpolation","text":"","category":"section"},{"location":"reference/interpolations/","page":"Interpolation","title":"Interpolation","text":"InterfaceCellInterpolation","category":"page"},{"location":"reference/interpolations/#FerriteInterfaceElements.InterfaceCellInterpolation","page":"Interpolation","title":"FerriteInterfaceElements.InterfaceCellInterpolation","text":"InterfaceCellInterpolation(here::ScalarInterpolation, there::ScalarInterpolation) <: ScalarInterpolation\n\nAn InterfaceCellInterpolation is an interpolation based on two interpolations on the faces of an InterfaceCell. If only one interpolation is given, it will be used for both faces.\n\nFields\n\nhere::ScalarInterpolation: interpolation on the face \"here\"\nthere::ScalarInterpolation: interpolation on the face \"there\"\n\n\n\n\n\n","category":"type"}]
}
